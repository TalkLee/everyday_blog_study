##trim方法实现:

背景知识：
trim指去除字符串首尾的空白符(空格、制表符等)


字符串(对象)的方法：

1.获取字符串指定位置字符

    var str1 = 'hello';
    console.log(str1.charAt(1));

2.获取字符串指定位置字符的编码

        var str1 = 'hello ';
        var str2 = 'world';
        console.log(str1.charAt(1)); //e

3.下表法访问指定位置字符(ECMAscript5标准)
        var str1 = 'hello ';
        var str2 = 'world';
        console.log(str1[1]);  //e

操作方法：

1.拼接：concat(),返回拼接好的字符串
    
        var str1 = 'hello ';
        var str2 = 'world';
        var concatedStr = str1.concat(str2);
        console.log(concatedStr); // hello world

2.截取字符串，返回值为截取获的的子字符串

2-1.slice:
    参数一指开始位置，参数二指结束位置的后一个字符

        var str1 = 'hello ';
        var str2 = 'world';
        console.log(str1.slice(1,3));  //el   


2-2. substr()



替换方法：

//待补充String的基本方法
















RegExp对象:


创建正则表达式:

1. var reg1 = /pattern/flag;
2. var reg2 = new RegExp("pattern",flag);  //flag此时为字符串
3. var reg3 = new RegExp(/pattern/,flag);  //flag此时为字符串

例：

        var reg = new RegExp('abc','gi');  
        var reg = /abc/gi;
        两者等价,即构造函数中无需添加pattern两边的/

构造函数生成正则的优点在于正则表达式动态变化的情况下可以传入变量

[向字符串中加入特殊字符,需要转义](http://www.w3school.com.cn/js/js_special_characters.asp)，即加入反斜杠 __\ __

字符转义:正则表达式中的元字符需要进行转义才能表示字面含义


元字符:
- \b 单词的分界处 , 匹配位置
- . 除了 __换行符__ 的任意 __字符__
- \d 匹配数字
- \s 匹配任意空白符(空格制表符换行符换页符中英文全角半角空格等)
- \w 匹配字母数字下划线
- ^ 匹配字符串的开始,匹配位置
- $ 匹配字符串的结束,匹配位置
- ( 和 )



当在正则表达式中添加元字符时，需要进行转义
当在构造函数的模式参数中添加元字符时，需要进行双重转义
例：
    
        //?在正则中表示非字面含义，若要表示字面含义，需通过\进行转义
        var reg = /\?/;  
        var reg2 = new RegExp("\?"); 在正则表达式构造函数参数字符串中正则表达式的量词都是需要被转义的特殊字符，所以\?实际表达含义为 '?' 
        //若要reg2表示含义和reg相同，需要对\做转义
        var reg3 = new RegExp("\\?");// \\表示后一个\被转义了，浏览器会看作字符串\?,等价于reg3 = /\?/ 


动态属性:
    lastIndex : 下次匹配开始的位置,可以被exec方法修改，可写
    ignoreCase:是否包含标志i
    global:是否包含标志g
    multiline:是否包含标志m
    source：正则表达式定义时模式字符串,与reg.toString()结果相同，包含斜杠和标志

静态属性:
    - input用于匹配的母串，当调用test和exect方法成功匹配后input属性被会自动修改为上次匹配的字符串
    - lastMatch 最后一次匹配成功的子串
    - lastParen 最后分配的分组号
    - leftContext 被查找字符串从字符串开始到最后匹配的位置之间的字符串
    - rightContext 被查找的字符串中从最后一个匹配位置开始到字符串结尾的字符串(不包括最后一个匹配位置后一个位置)
    - 





实例方法:
 
 1. exec()
 param：String
 返回包含该查找结果的一个数组,无匹配时返回null
 数组第一个元素为匹配的子串,剩余元素保存被匹配的正则的各个分组
 还包含其他属性:被匹配的
 index:匹配到的子串首字母在母串中的位置
 input:原始字符串(母串)
 同时在比较过后，正则表达式的lastIndex属性也随之更新




 2. test()  
 param1:String
 规则:参数(字符串)中存在与正则匹配的子串的情况下返回true,否则false


 3. compile()

 
String对象:

实例方法:

 1. match()
 param1:String
 将查找结果作为数组返回,每个元素为一个匹配的子串
 不使用全局匹配的话，数组中只包含匹配子串，
 返回数组包含三个属性:
    - input 属性包含整个被查找的字符串
    - index包含在整个被查找字符串中匹配的子字符串的位置
    - lastIndex包含了最后一次匹配中最后一个字符的下一个文职
    
 2. replace()
 param1: 正则表达式或者字符串
 param2:替换字符串
 用替换字符串替换与正则表达式匹配的子串


 3. search()
 param:
 返回与正则表达式相匹配的子串首字母在母串中下标

 4. split()
 param:字符串或者正则
 把字符串按照参数提供的规则分割为字符串数组

 

反向引用:
包含分组的正则表达式在被与正则有关的方法调用后，每个分组所匹配的子串保存在RegExp对象的$n属性中，称为反向引用

可以通过RegExp.$n来在程序中调用，
也可以通过\n在正则表达式中使用


对于replace方法,反向引用可以在替换字符串中使用

str.replace(reg,'12'); //1 2 分别表示分组1和2





###正则表达式相关知识


限定符(设置匹配字符串数量)

- *匹配0到多个
- +匹配1到多个
- ? 匹配0或1个
- {n} 匹配n个
- {n,}至少匹配n个
- {n,m} 匹配n到m个


字符类：设置字符集合来匹配指定范围内的字符

 例:  [a-z0-9A-Z]  匹配所有单个英文字母和数字


分支条件:满足任意一种规则,即退出当前分组 

子表达式(分组):
    例: (123)  为一个分组，匹配时看作一个整体


反义：

- \W 匹配任意不是字母数字下划线的字符
- \S 匹配任意不是空白符的字符
- \D 匹配任意非数字的字符
- \B 匹配非单词边界
- [^x] 匹配除x以外的任意字符
- [^abcd] 匹配除abcd以外的任意字符

后向引用:小括号指定的子表达式当被文本匹配，可以对匹配的文本进行处理,
默认情况下，每个分组自动拥有一个组号，以分组左括号为标志，按照出现顺序从1开始计数。__用于重复搜索之前某个分组匹配的文本__



- (pattern): 捕获括号，用于获取匹配到的字符串，然后用于后续处理
- (?:pattern):非捕获分组，匹配到的子串无法通过结果数组的下标进行访问
- 引用捕获到的分组，应使用\num方法，其中num表示对应捕获分组的编号
- (?=pattern)：正向预查，在任何匹配pattern，非捕获匹配，断言自身出现的位置后面能匹配表达式exp
- (?!pattern): 负向预查，非捕获匹配



/^([a-z])\1$/  : 匹配连续的两个相同小写字母
在被替换的字符串中引用捕获分组，应使用$num记法




零宽断言:


零宽度正预测先行断言: 表示获取出现在设定的正则所匹配的字符串之前的字符串
例：(?=exp)  用来获取匹配exp的子串前面的字符串





    



贪婪:正则表达式通常匹配尽可能多的字符
懒惰匹配:在限定符后面加上__?__即可匹配尽量少的字符

- *？匹配任意次，尽可能少
- +? 匹配1至多次，尽可能少
- ?? 匹配0或1次，尽可能少
- {n,m} 匹配n到m次，尽可能少
- {n,} 匹配至少n次，尽可能少



优先级(由高到低)：
- 转义符
- 括号
- 限定符
- 位置和顺序
- | 



标志：
- i (ignoreCase)，忽略大小写
- m (Multiline),多行匹配
- g global 全局匹配




###trim问题解析: